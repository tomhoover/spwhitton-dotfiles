#!/usr/bin/perl

# Cold (offline) backups & other elements in a weekly maintenance routine

# The idea is that if this script dies it can be safely be re-run from the beginning

# Note that each backup drive needs a unique filesystem label!

use strict;
use warnings;
use lib "$ENV{HOME}/lib/perl5";
no warnings "experimental::smartmatch";

use Term::UI;
use ShellSequence;
use ScriptStatus;
use File::Grep "fgrep";
use File::Basename;
use File::chdir;
use Capture::Tiny qw/capture_merged capture/;
use List::MoreUtils "apply";
use File::Spec::Functions "rel2abs";
use Sys::Hostname;

my $seq = ShellSequence->new();
my $term = Term::ReadLine->new('brand');
my $host = hostname;

# ---- config

our @gcrypt_repos = qw/priv.git annex.git rt.git/;
our @src_exceptions = qw/hscripts/;
our $git = "/home/git";

# ---- prep

chdir $ENV{HOME};
system "mount lib/athena 2>/dev/null" || 1;
my ($loc, $drive_name, $short_drive_name);

if (@ARGV) {
    $loc = rel2abs(shift @ARGV);
    die "$loc is not a directory" unless ( -d $loc );
    my @mountpoints = split /^/, `mount | cut -d' ' -f3`;
    @mountpoints = apply { $_ =~ s/^\s+|\s+$//g } @mountpoints;
    $drive_name = $loc;
    $short_drive_name = basename $drive_name;
    die "$loc is not a removable drive" unless ( $drive_name ~~ @mountpoints );

    if ( ! -d "$loc/gitbk" ) {
        status "it looks like you haven't backed up to this media before";
        my $create = $term->ask_yn(prompt => "Create a new backup repository at $loc/gitbk?");
        if ($create) {
            mkdir "$loc/gitbk"
              or die "couldn't create $loc/gitbk -- check permissions";
        } else {
            exit 1;
        }
    }
} else {
    status "you didn't specify a drive to perform a coldbkup to as a command";
    status "line argument to this script";
    exit unless $term->ask_yn(
                              prompt => "Continue sysmaint without coldbkup?",
                              default => 'y',
                             );
}

# ---- pre-backup cleanup tasks

$seq->add_should_zero("ls tmp");
$seq->add_should_zero("ssh athena ls tmp");
$seq->add_should_zero("ssh athena ls local/files/tmp");
$seq->add_should_zero("ls lib/athena/tmp");
$seq->run();

status "cleaning up ~/src";
# we retain orig tarballs
unlink glob "src/*.dsc";
unlink glob "src/*.diff.gz";
unlink glob "src/*.upload";
unlink glob "src/*.inmulti";
unlink glob "src/*.changes";
unlink glob "src/*.deb";
unlink glob "src/*.build";
unlink glob "src/*.buildinfo";
unlink glob "src/*.debian.tar.*";
unlink glob "src/*[0-9].tar.*"; # native package generated tarballs
system "clean-patch-queues -y";

while (42) {
    my $output = capture_merged { find_dirty_src() };
    if (length $output) {
        status "the following files/repos in ~/src should be cleaned up:";
        print $output;
        my $again = $term->ask_yn(
                                  prompt => "Check for files in ~/src again?",
                                  default => 'y',
                                 );
        last unless $again;
    } else {
        last;
    }
}

# ---- standard backup procedure

$seq->add_should_zero("mr -ms misstowed --delete-unmodified");
$seq->add_should_succeed("mr -ms restow");
$seq->add_should_succeed("mr -ms autoci");
# `mr -ms isclean` checks for stuff to be checked in ...
$seq->add_should_succeed("mr -ms isclean");
$seq->add_should_succeed("mr -s up");
$seq->add_should_succeed("mr -s push");
# ... then `mr -ms status` finds unpushed branches & stashes
$seq->add_should_zero("mr -ms status");

$seq->run();

# ---- backup to offline media ("coldbkup" was old script name)

# TODO error handling here: since we're not using $seq for everything
if ( defined $loc ) {

    # ---- github-backup
    {
        mkdir "$loc/gitbk/github" unless ( -d "$loc/gitbk/github" );
        local $CWD = "$loc/gitbk/github";
        $seq->add_should_succeed("github-backup spwhitton");
        $seq->run();
    }

    # ---- athena repos
    my $athena_repos = capture {
        system "ssh athena 'for d in $git/*; do echo \$d; done'";
    };
    my @athena_repos = split /^/, $athena_repos;
    @athena_repos = apply { s|$git/|| } @athena_repos;
    foreach my $repo ( @athena_repos ) {
        $repo =~ s/\n//g;
        # TODO detect gcrypt repo down in backup_repo function (only
        # need to detect on clone, not update) -- see git-remote-gcrypt manpage for how to do this
        # TODO ensure we don't detect rt.git as a gcrypt repo tho as don't want to init it ...
        if ( $repo eq "priv.git" ) {
            backup_repo("gcrypt::rsync://athena:/home/git/$repo", "athena");
        } elsif ( $repo ~~ @gcrypt_repos ) {
            backup_repo("gcrypt::git\@spwhitton.name:$repo", "athena");
        } else {
            backup_repo("git\@spwhitton.name:$repo", "athena");
        }
    }

    # ---- misc. repos

    # Debian packages I'm responsible for, and a few other Debian repos

    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/wiki.git", "alioth", "pkg-emacsen");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/dh-elpa.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/dh-make-elpa.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/yasnippet.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/ebib.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-async.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-buttercup.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-highlight-indentation.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-noflet.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/epl.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/f-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/flx.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/flycheck.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/helm.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/let-alist.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/paredit-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/parsebib.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/perspective-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/pkg-info-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/popup-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/projectile.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/persp-projectile.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/helm-projectile.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/rainbow-delimiters.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/seq-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/s-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/shut-up.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/smex.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/ws-butler.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/zenburn-emacs.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/aggressive-indent-mode.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/ert-async-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/git-annex-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/debpaste-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/magit-annex.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/xml-rpc-el.git", "alioth");

    backup_repo("https://anonscm.debian.org/git/pkg-mozext/classic-theme-restorer.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/keysnail.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/ublock-origin.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/y-u-no-validate.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/self-destructing-cookies.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/collab-maint/mairix.git", "alioth");

}

# TODO luksClose if necessary & umount
# system "sudo umount $loc";

# ---- remote system maintenance

# TODO put a flag file on athena so this only happens once per week
# or, better, just rework this so I ssh to athena and run sysmaint
# there

status "info: you can unmount & eject $loc";
exit unless $term->ask_yn(
                          prompt =>
                          "Backups complete.  Perform remote & local system maintainance?"
                         );

status "checking athena's storage";
system "ssh athena df -h";
my $disc_space_okay = $term->ask_yn(
                                    prompt => "Does athena have enough free disc space?",
                                    default => 'y',
                                   );
die "deal with athena's low free disc space" unless $disc_space_okay;

status "checking athena's uptime";
system "ssh athena uptime";
my $athena_rebooted = $term->ask_yn(
                                    prompt => "Was athena rebooted?",
                                    default => 'n',
                                   );
die "perform athena reboot procedure" if $athena_rebooted;

$seq->add_should_succeed("ssh -t athena 'sudo apt-get update && sudo apt-get upgrade && sudo apt-get autoremove && sudo apt-get autoclean'");

# ---- local system maintenance

# clean packages installed by mk-build-deps(1)
$seq->add_should_succeed("sudo aptitude remove '~n-build-deps\$'");

$seq->add_should_succeed("sudo apt-get update");
$seq->add_should_succeed("sudo apt-get upgrade");
$seq->add_should_succeed("sudo apt-get dist-upgrade");
$seq->add_should_succeed("sudo apt-get -y autoremove");

$seq->add_should_zero("mailq | grep -v 'Mail queue is empty'");
$seq->add_should_zero("ssh athena mailq | grep -v 'Mail queue is empty'");

$seq->run();

# ---- subroutines

# TODO delete all but the two highest-versioned orig.tars for each package
# TODO delete orig.tar if the repo is not actually present
# TODO src-unregister script to delete entry from ~/src/.mrconfig and nuke the repo

sub find_dirty_src {
    foreach my $f ( glob "src/*" ) {
        my $short = basename($f);
        unless ( (-f $f && $f =~ /orig\.tar/)
                 # also permit symlinks to orig tarballs
                 || (-l $f && $f =~ /orig\.tar/)
                 # also permit gbp orig tarballs
                 || ($f =~ /orig\.gbp\.tar/)
                 || $short ~~ @src_exceptions
                 || (-d "$f/.git"
                     && ((fgrep { /^\[$short\]$/ } "src/.mrconfig")
                         || (fgrep { /^\[$f\]$/ } ".mrconfig")))) {
            if (-d "$f/.git") {
                local $CWD = $f;
                system "mr register >/dev/null";
                print "$f\n" if ($? >> 8 != 0);
            } else {
                print "$f\n";
            }
        }
    }
}

sub backup_repo {
    my ( $long, $dest, $rename ) = @_;
    my $short;

    # clear out the command sequencer
    $seq->run();
    # third param is optional: do we need to rename it because
    # remote's name is too generic (e.g. 'wiki')?
    if ( defined $rename ) {
        $short = $rename;
    } else {
        ( undef, $short ) = split /:([^:]+)$/, $long;
    }

    $short = basename $short;    # just in case
    $short = "$short.git" unless $short =~ /\.git$/;
    $dest = "$loc/gitbk/$dest";
    my $dir = "$dest/$short";
    status "backup source: $long";
    status "backup dest:   $dir";

    # first we have to determine whether it's an annex, as that will
    # affect the commands we run both to clone and to update
    # TODO generalise this to work for non-athena annexes
    my $annex = 0;
    if ( $dest eq "$loc/gitbk/athena" ) {
        ( undef, undef, my $exit ) = capture {
            system "ssh athena ls $git/$short/annex";
        };
        $annex = $exit >> 8 == 0;
    }

    if ( -e $dir ) {            # repo already backed up to this drive
        local $CWD = $dir;
        # TODO second disjunct in to allow for non-bare repos on
        # backup drive, e.g. gitbk/athena/annex on m3.  At present,
        # gitbk/athena/annex.git is a symlink to gitbk/athena/annex.
        # We should be able to handle this without the symlink, in
        # this script
        if ( -d "annex" || -d ".git/annex" ) {
            system "git config annex.diskreserve '2GB'";
            # TODO ask user before pairing since it's a guess
            if ( my $host_repo = find_host_annex($short) ) {
                status "pairing $short with $host_repo";
                local $CWD = $host_repo;
                system "git remote add $short_drive_name $dir 2>/dev/null" || 1;
                $seq->add_should_succeed("git annex sync --content $short_drive_name");
                $seq->run();
                # TODO now metadata sync with origin remote, if it exists
            } else {
                # TODO extend ShellSequence to run arbitrary perl,
                # then this whole thing can be retried
                status "couldn't pair $short with host; not syncing it";
                my $acknowledged = $term->ask_yn(
                                                 prompt => "Acknowledged?",
                                                 default => 'y',
                                                );
            }
        } else {
            $seq->add_should_succeed("git fetch origin '+refs/heads/*:refs/heads/*' --tags --no-prune");
            $seq->run();
        }
    } else {                    # repo new to this drive
        if ($annex) {
            mkdir "$dest" unless ( -d $dest );
            local $CWD = $dest;
            # bare repos don't get a reflog by default
            system "git -c core.logAllRefUpdates=true clone --bare $long $short";
            {
                local $CWD = $dir;
                system "git annex init '$short_drive_name'";
                system "git config annex.diskreserve '2GB'";
                # only set preferred content settings on a first init,
                # so that the user can override for this particular
                # backup drive
                system "git annex wanted . standard";
                system "git annex group . incrementalbackup";
                # TODO ask user before pairing since it's a guess
                if ( my $host_repo = find_host_annex($short) ) {
                    status "pairing $short with $host_repo";
                    local $CWD = $host_repo;
                    system "git remote add $short_drive_name $dir 2>/dev/null" || 1;
                    $seq->add_should_succeed("git annex sync --content $short_drive_name");
                    $seq->run();
                    # TODO now metadata sync with origin remote, if it exists
                } else {
                    status "couldn't pair $short with host; not syncing it";
                    my $acknowledged = $term->ask_yn(
                                                     prompt => "Acknowledged?",
                                                     default => 'y',
                                                    );
                }
            }
        } else {
            mkdir "$dest" unless ( -d $dest );
            local $CWD = $dest;
            # bare repos don't get a reflog by default
            $seq->add_should_succeed("git -c core.logAllRefUpdates=true clone --mirror $long $short");
            $seq->run;
        }
    }

    # Protect our backup from being reaped by git-gc
    {
        local $CWD = $dir;
        # Enable the reflog, since it is off by default in bare repos.
        # Since we fetch with --no-prune, no reflogs will ever get
        # deleted, so we have one for every branch that ever existed
        # in the remote we're backing up (that existed at a time we
        # ran this script, at least)
        system "git config core.logAllRefUpdates true";
        # Never remove reflog entries
        system "git config gc.reflogExpire never";
        # git-gc will never remove dangling commits mentioned in any
        # reflog *unless* they are unreachable in the branch the
        # reflog logs and are older than this config variable
        system "git config gc.reflogExpireUnreachable never";
        # avoid backing up broken commits
        system "git config fetch.fsckObjects true";
    }
}

sub find_host_annex {
    my $annex = shift;
    $annex =~ s|\.git$||;

    # parse output of `mr list`
    my @my_repos = split /^/, `mr -d $ENV{HOME} list`;
    @my_repos = apply { s/mr list:// } @my_repos;
    @my_repos = apply { $_ =~ s/^\s+|\s+$//g } @my_repos;
    @my_repos = grep { /^\// } @my_repos;

    # TODO check if they have any commits in common
    my @found = grep { $_ =~ /\/$annex$/ } @my_repos;
    return $found[0] if ( scalar @found == 1 );
}

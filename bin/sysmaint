#!/usr/bin/perl

# Cold (offline) backups & other elements in a weekly maintenance routine

# The idea is that if this script dies it can be safely be re-run from the beginning

use strict;
use warnings;
use lib "$ENV{HOME}/lib/perl5";
no warnings "experimental::smartmatch";

use Term::UI;
use ShellSequence;
use ScriptStatus;
use File::Grep "fgrep";
use File::Basename;
use File::chdir;
use Capture::Tiny qw/capture_merged capture/;
use List::MoreUtils "apply";
use File::Spec::Functions "rel2abs";
use Sys::Hostname;

my $seq = ShellSequence->new();
my $term = Term::ReadLine->new('brand');
my $host = hostname;

# ---- config

our @gcrypt_repos = qw/priv.git annex.git rt.git/;
our @src_exceptions = qw/hscripts/;
our $git = "/home/git";

# ---- prep

chdir $ENV{HOME};
system "mount lib/fm 2>/dev/null" || 1;
my ($loc, $drive_name, $short_drive_name);

if (@ARGV) {
    $loc = rel2abs(shift @ARGV);
    die "$loc is not a directory" unless ( -d $loc );
    my @mountpoints = split /^/, `mount | cut -d' ' -f3`;
    @mountpoints = apply { $_ =~ s/^\s+|\s+$//g } @mountpoints;
    $drive_name = $loc;
    $short_drive_name = basename $drive_name;
    die "$loc is not a removable drive" unless ( $drive_name ~~ @mountpoints );

    if ( ! -d "$loc/gitbk" ) {
        status "it looks like you haven't backed up to this media before";
        my $create = $term->ask_yn(prompt => "Create a new backup repository at $loc/gitbk?");
        if ($create) {
            mkdir "$loc/gitbk"
              or die "couldn't create $loc/gitbk -- check permissions";
        } else {
            exit 1;
        }
    }
} else {
    status "you didn't specify a drive to perform a coldbkup to as a command";
    status "line argument to this script";
    exit unless $term->ask_yn(
                              prompt => "Continue sysmaint without coldbkup?",
                              default => 'y',
                             );
}

# ---- pre-backup cleanup tasks

$seq->add_should_zero("ls tmp");
$seq->add_should_zero("ssh athena ls tmp");
$seq->add_should_zero("ls lib/fm/tmp");
$seq->run();

status "cleaning up ~/src";
# we retain orig tarballs
unlink glob "src/*.dsc";
unlink glob "src/*.upload";
unlink glob "src/*.changes";
unlink glob "src/*.deb";
unlink glob "src/*.build";
unlink glob "src/*.debian.tar.*";
unlink glob "src/*[0-9].tar.*"; # native package generated tarballs
system "clean-patch-queues -y";

while (42) {
    my $output = capture_merged { find_dirty_src() };
    if (length $output) {
        status "the following files/repos in ~/src should be cleaned up:";
        print $output;
        my $again = $term->ask_yn(
                                  prompt => "Check for files in ~/src again?",
                                  default => 'y',
                                 );
        last unless $again;
    } else {
        last;
    }
}

# ---- standard backup procedure

$seq->add_should_zero("mr -ms misstowed --delete-unmodified");
$seq->add_should_succeed("mr -ms restow");
$seq->add_should_succeed("mr -ms autoci");
# `mr -ms isclean` checks for stuff to be checked in ...
$seq->add_should_succeed("mr -ms isclean");
$seq->add_should_succeed("mr -j1 -s up");
$seq->add_should_succeed("mr -j1 -s push origin --tags :");
# ... then `mr -ms status` finds unpushed branches
$seq->add_should_zero("mr -ms status");

$seq->run();

# ---- backup to offline media ("coldbkup" was old script name)

# TODO error handling here: since we're not using $seq for everything
if ( defined $loc ) {

    # ---- github-backup
    {
        mkdir "$loc/gitbk/github" unless ( -d "$loc/gitbk/github" );
        local $CWD = "$loc/gitbk/github";
        $seq->add_should_succeed("github-backup spwhitton");
        $seq->run();
    }

    # ---- athena repos
    my $athena_repos = capture {
        system "ssh athena 'for d in $git/*; do echo \$d; done'";
    };
    my @athena_repos = split /^/, $athena_repos;
    @athena_repos = apply { s|$git/|| } @athena_repos;
    foreach my $repo ( @athena_repos ) {
        $repo =~ s/\n//g;
        # TODO detect gcrypt repo down in backup_repo function (only
        # need to detect on clone, not update)
        if ( $repo ~~ @gcrypt_repos ) {
            backup_repo("gcrypt::git\@spwhitton.name:$repo", "athena");
        } else {
            backup_repo("git\@spwhitton.name:$repo", "athena");
        }
    }

    # ---- misc. repos

    # Debian packages I'm responsible for

    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/dh-elpa.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/dh-make-elpa.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/ebib.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-async.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-buttercup.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-highlight-indentation.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-noflet.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/epl.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/f-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/flx.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/flycheck.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/helm.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/let-alist.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/paredit-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/parsebib.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/perspective-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/pkg-info-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/popup-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/projectile.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/rainbow-delimiters.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/seq-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/shut-up.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/smex.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/ws-butler.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/zenburn-emacs.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/aggressive-indent-mode.git", "alioth");

    backup_repo("https://anonscm.debian.org/git/pkg-mozext/classic-theme-restorer.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/keysnail.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/ublock-origin.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/y-u-no-validate.git", "alioth");

}

# TODO luksClose if necessary & umount
# system "sudo umount $loc";

# ---- remote system maintenance

exit unless $term->ask_yn(
                          prompt =>
                          "Backups complete.  Perform remote & local system maintainance?"
                         );

status "checking athena's storage";
system "ssh athena df -h";
my $disc_space_okay = $term->ask_yn(
                                    prompt => "Does athena have enough free disc space?",
                                    default => 'y',
                                   );
die "deal with athena's low free disc space" unless $disc_space_okay;

status "checking athena's uptime";
system "ssh athena uptime";
my $athena_rebooted = $term->ask_yn(
                                    prompt => "Was athena rebooted?",
                                    default => 'n',
                                   );
die "perform athena reboot procedure" if $athena_rebooted;

$seq->add_should_succeed("ssh -t athena 'sudo apt-get update && sudo apt-get upgrade && sudo apt-get autoremove && sudo apt-get autoclean'");

# ---- local system maintenance

$seq->add_should_succeed("sudo apt-get update");
$seq->add_should_succeed("sudo apt-get upgrade");
$seq->add_should_succeed("sudo apt-get dist-upgrade");
$seq->add_should_succeed("sudo apt-get -y autoremove");

$seq->add_should_zero("mailq | grep -v 'Mail queue is empty'");
$seq->add_should_zero("ssh athena mailq | grep -v 'Mail queue is empty'");

$seq->run();

# ---- subroutines

sub find_dirty_src {
    foreach my $f ( glob "src/*" ) {
        my $short = basename($f);
        unless ( (-f $f && $f =~ /orig\.tar/)
                 || $short ~~ @src_exceptions
                 || (-d "$f/.git"
                     && ((fgrep { /^\[$short\]$/ } "src/.mrconfig")
                         || (fgrep { /^\[$f\]$/ } ".mrconfig")))) {
            if (-d "$f/.git") {
                local $CWD = $f;
                system "mr register >/dev/null";
                print "$f\n" if ($? >> 8 != 0);
            } else {
                print "$f\n";
            }
        }
    }
}

sub backup_repo {
    my ( $long, $dest ) = @_;
    my ( undef, $short ) = split /:([^:]+)$/, $long;
    $short = basename $short;    # just in case
    $short = "$short.git" unless $short =~ /\.git$/;
    $dest = "$loc/gitbk/$dest";
    my $dir = "$dest/$short";
    status "backup source: $long";
    status "backup dest:   $dir";

    # first we have to determine whether it's an annex, as that will
    # affect the commands we run both to clone and to update
    # TODO generalise this to work for non-athena annexes
    my $annex = 0;
    if ( $dest eq "$loc/gitbk/athena" ) {
        ( undef, undef, my $exit ) = capture {
            system "ssh athena ls $git/$short/annex";
        };
        $annex = $exit >> 8 == 0;
    }

    if ( -e $dir ) {            # repo already backed up to this drive
        local $CWD = $dir;
        if ( -d "annex" ) {
            system "git config annex.diskreserve '2GB'";
            # TODO ask user before pairing since it's a guess
            # if ( my $host_repo = find_host_annex($short) ) {
            #     status "pairing $short with $host_repo";
            #     system "git remote add $host $host_repo 2>/dev/null" || 1;
            # }
            # commented out for summer
            # --no-commit because bare
            # system "git annex sync --content --no-commit"
        } else {
            # we could --prune here, but for backup purposes just pull
            # them all in
            system "git fetch origin '+refs/heads/*:refs/heads/*' --tags";
        }
    } else {                    # repo new to this drive
        if ($annex) {
            mkdir "$dest" unless ( -d $dest );
            local $CWD = $dest;
            system "git clone --bare $long $short";
            {
                local $CWD = $dir;
                system "git annex init '$short_drive_name'";
                system "git config annex.diskreserve '2GB'";
                # only set preferred content settings on a first init,
                # so that the user can override for this particular
                # backup drive
                system "git annex wanted . standard";
                system "git annex group . incrementalbackup";
                # TODO ask user before pairing since it's a guess
                # if ( my $host_repo = find_host_annex($short) ) {
                #     status "pairing $short with $host_repo";
                #     system "git remote add $host $host_repo 2>/dev/null" || 1;
                # }
                # commented out for summer
                # --no-commit because bare
                # system "git annex sync --content --no-commit"
            }
        } else {
            mkdir "$dest" unless ( -d $dest );
            local $CWD = $dest;
            system "git clone --mirror $long $short";
        }
    }
}

sub find_host_annex {
    my $annex = shift;
    $annex =~ s|\.git$||;

    # parse output of `mr list`
    my @my_repos = split /^/, `mr -d $ENV{HOME} list`;
    @my_repos = apply { s/mr list:// } @my_repos;
    @my_repos = apply { $_ =~ s/^\s+|\s+$//g } @my_repos;
    @my_repos = grep { /^\// } @my_repos;

    # TODO check if they have any commits in common
    my @found = grep { $_ =~ /\/$annex$/ } @my_repos;
    return $found[0] if ( scalar @found == 1 );
}

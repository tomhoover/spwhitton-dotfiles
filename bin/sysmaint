#!/usr/bin/perl

# Cold (offline) backups & other elements in a weekly maintenance routine

# The idea is that if this script dies it can be safely be re-run from the beginning

use strict;
use warnings;
use lib "$ENV{HOME}/lib/perl5";
no warnings "experimental::smartmatch";

use Term::UI;
use ShellSequence;
use ScriptStatus;
use File::Grep "fgrep";
use File::Basename;
use File::chdir;
use Capture::Tiny qw/capture_merged capture/;
use List::MoreUtils "apply";
use File::Spec::Functions "rel2abs";

my $seq = ShellSequence->new();
my $term = Term::ReadLine->new('brand');

# ---- prep

chdir $ENV{HOME};
system "mount lib/fm 2>/dev/null" || 1;
my ($loc, $drive_name);

if (@ARGV) {
    $loc = rel2abs(shift @ARGV);
    die "$loc is not a directory" unless ( -d $loc );
    my @mountpoints = split /^/, `mount | cut -d' ' -f1`;
    die "$loc is not a removable drive" unless ( $loc ~~ @mountpoints );
    $drive_name = basename $loc;

    if ( ! -d "$loc/gitbk" ) {
        status "it looks like you haven't backed up to this media before";
        my $create = $term->ask_yn(prompt => "Create a new backup repository at $loc/gitbk?");
        if ($create) {
            mkdir "$loc/gitbk";
        } else {
            exit 1;
        }
    }
} else {
    status "you didn't specify a drive to perform a coldbkup to as a command";
    status "line argument to this script";
    exit unless $term->ask_yn(
                              prompt => "Continue sysmaint without coldbkup?",
                              default => 'y',
                             );
}

# ---- pre-backup cleanup tasks

$seq->add_should_zero("ls tmp");
$seq->add_should_zero("ssh athena ls tmp");
$seq->add_should_zero("ls lib/fm/tmp");
$seq->run();

status "cleaning up ~/src";
# we retain orig tarballs
unlink glob "src/*.dsc";
unlink glob "src/*.upload";
unlink glob "src/*.changes";
unlink glob "src/*.deb";
unlink glob "src/*.build";
unlink glob "src/*.debian.tar.*";

while (42) {
    my $output = capture_merged { find_dirty_src() };
    if (length $output) {
        status "the following files/repos in ~/src should be cleaned up:";
        print $output;
        my $again = $term->ask_yn(
                                  prompt => "Check for files in ~/src again?",
                                  default => 'y',
                                 );
        last unless $again;
    } else {
        last;
    }
}

# ---- standard backup procedure

$seq->add_should_zero("mr -ms misstowed --delete-unmodified");
$seq->add_should_succeed("mr -ms restow");
$seq->add_should_succeed("mr -ms autoci");
# `mr -ms isclean` checks for stuff to be checked in ...
$seq->add_should_succeed("mr -ms isclean");
$seq->add_should_succeed("mr -s up");
$seq->add_should_succeed("mr -s push origin --tags :");
# ... then `mr -ms status` finds unpushed branches
$seq->add_should_zero("mr -ms status");

$seq->run();

# ---- backup to offline media ("coldbkup" was old script name)

# TODO error handling here: since we're not using $seq for everything
if ( defined $loc ) {

    # ---- github-backup
    {
        mkdir "$loc/gitbk/github 2>/dev/null" || 1;
        local $CWD = "$loc/gitbk/github";
        $seq->add_should_succeed("github-backup spwhitton");
        $seq->run();
    }

    # ---- athena repos
    my $git = "/home/git";
    my @gcrypt_repos = qw/priv.git annex.git rt.git/;
    my $athena_repos = capture {
        system "ssh athena 'for d in $git/*; do echo \$d; done'";
    };
    my @athena_repos = split /^/, $athena_repos;
    @athena_repos = apply { s|$git|| } @athena_repos;
    foreach my $repo ( @athena_repos ) {
        # TODO detect gcrypt repo down in backup_repo function (only
        # need to detect on clone, not update)
        if ( $repo ~~ @gcrypt_repos ) {
            backup_repo("gcrypt::git\@spwhitton.name:$repo", "athena");
        } else {
            backup_repo("git\@spwhitton.name:$repo", "athena");
        }
    }

    # ---- try to pair and sync (personal) annexes

    # find the annexes
    my @annexes;
    foreach my $repo ( @athena_repos ) {
        ( my $output, my $exit ) = capture {
            system "ssh athena ls $git/$repo/annex";
        };
        $exit = $exit >> 8;
        push @annexes, $repo if ( $exit == 0 );
    }

    foreach my $annex ( @annexes ) {
        local $CWD = "$loc/gitbk/athena/$annex";
        # init them and ensure sane config
        system "git annex init '$drive_name'";

        # try to add local remote

        # finally, sync content
    }

    # ---- misc. repos
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/aggressive-indent-mode.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/f-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-async.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/emacs-noflet.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/perspective-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/helm.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/epl.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/pkg-info-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/flx.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/projectile.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/let-alist.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/seq-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/shut-up.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/popup-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/paredit-el.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/ublock-origin.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/y-u-no-validate.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/classic-theme-restorer.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-emacsen/pkg/flycheck.git", "alioth");
    backup_repo("https://anonscm.debian.org/git/pkg-mozext/keysnail.git", "alioth");

}

system "sudo umount $loc";

# ---- remote system maintenance

exit unless $term->ask_yn(
                          prompt =>
                          "Backups complete.  Perform remote & local system maintainance?"
                         );

status "checking athena's storage";
system "ssh athena df -h";
my $disc_space_okay = $term->ask_yn(
                                    prompt => "Does athena have enough free disc space?",
                                    default => 'y',
                                   );
die "deal with athena's low free disc space" unless $disc_space_okay;

status "checking athena's uptime";
system "ssh athena uptime";
my $athena_rebooted = $term->ask_yn(
                                    prompt => "Was athena rebooted?",
                                    default => 'n',
                                   );
die "perform athena reboot procedure" if $athena_rebooted;

$seq->add_should_succeed("ssh -t athena 'sudo apt-get update && sudo apt-get upgrade && sudo apt-get autoremove && sudo apt-get autoclean'");

# ---- local system maintenance

$seq->add_should_succeed("sudo apt-get update");
$seq->add_should_succeed("sudo apt-get upgrade");
$seq->add_should_succeed("sudo apt-get dist-upgrade");
$seq->add_should_succeed("sudo apt-get -y autoremove");

$seq->add_should_zero("mailq | grep -v 'Mail queue is empty'");
$seq->add_should_zero("ssh athena mailq | grep -v 'Mail queue is empty'");

$seq->run();

# ---- subroutines

sub find_dirty_src {
    my @src_exceptions = qw/hscripts/;
    foreach my $f ( glob "src/*" ) {
        my $short = basename($f);
        unless ( (-f $f && $f =~ /orig\.tar/)
                 || $short ~~ @src_exceptions
                 || (-d "$f/.git"
                     && ((fgrep { /^\[$short\]$/ } "src/.mrconfig")
                         || (fgrep { /^\[$f\]$/ } ".mrconfig")))) {
            if (-d "$f/.git") {
                local $CWD = $f;
                system "mr register >/dev/null";
                print "$f\n" if ($? >> 8 != 0);
            } else {
                print "$f\n";
            }
        }
    }
}

sub backup_repo {
    my ( $long, $dest ) = @_;
    my $short = basename $long;
    $short = "$short.git" unless $short =~ /\.git$/;
    $dest = "$loc/gitbk/$dest";
    my $dir = "$dest/$short";
    status "backing up repo $long to $dir";
    if ( -e $dir ) {
        local $CWD = $dir;
        # we could --prune here, but for backup purposes just pull
        # them all in
        system "git fetch origin '+refs/heads/*:refs/heads/*' --tags"
    } else {
        mkdir "$dest 2>/dev/null" || 1;
        local $CWD = $dest;
        system "git clone --mirror $long $short"
    }
}

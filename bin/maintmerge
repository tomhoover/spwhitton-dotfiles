#!/bin/sh

# Prepare a source package for dgit-maint-merge(7)

# TODO Generalise to some sort of script for any kind of project skeleton code

if ! (git diff-index --quiet --cached HEAD && \
          git diff-files --quiet && \
          test -z "$(git status --porcelain)" \
     ) >/dev/null 2>&1; then
    echo >&2 "please commit first"
    exit 1
fi

if ! [ -f "debian/changelog" ]; then
    echo >&2 "this doesn't look like a source package"
    exit 1
fi

if ! [ -d ".git" ]; then
    echo >&2 "please `git init`"
    exit 1
fi

source=$(dpkg-parsechangelog -SSource)

mkdir -p debian/source
echo "single-debian-patch" >>debian/source/options
echo "auto-commit" >>debian/source/options
git add debian/source/options

# TODO after substituting $source, word-wrap the paragraphs
cat >debian/source/patch-header <<EOF
The Debian packaging of $source is maintained in git, using the merging
workflow described in dgit-maint-merge(7).  There isn't a patch
queue that can be represented as a quilt series.

A detailed breakdown of the changes is available from their
canonical representation - git commits in the packaging repository.
For example, to see the changes made by the Debian maintainer in
the first upload of upstream version 1.2.3, you could use:

    % git clone https://git.dgit.debian.org/$source
    % cd $source
    % git log --oneline 1.2.3..debian/1.2.3-1 -- . ':!debian'

(If you have dgit, use \`dgit clone $source\`, rather than plain \`git
clone\`.)

A single combined diff, containing all the changes, follows.
EOF
git add debian/source/patch-header

git commit -m "Source package configuration for dgit-maint-merge(7)"

dgit setup-new-tree

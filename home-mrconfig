# -*- mode: conf -*-

[DEFAULT]

# --- global settings

# custom command for git
git_gc = git gc "$@"

# avoid hangs due to SSH connection sharing
jobs = 1

# custom actions to be configured repository-by-repository
git_sync = :
git_rebase = :
git_autoci = :

# avoid pushing non-matching branches, while trying to avoid errors
# from trying to push to read-only remotes
git_push = git push-all

# find dirty working directories, i.e., uncommitted changes and
# untracked files
# TODO possibly improve this by looking at git_status in /usr/bin/mr
git_isclean = 
    (
     # 1st line: check HEAD versus index
     # 2nd line: index versus working tree
     # 3rd line: untracked files
        git diff-index --quiet --cached HEAD && \
            git diff-files --quiet && \
            test -z "$(git status --porcelain)"
    ) || (git status --porcelain && exit 1)

# --- Experimental plugin for dgit repos

include = [ -e ~/src/dotfiles/lib/mr/dgit ] && cat ~/src/dotfiles/lib/mr/dgit

# Redefine git_update to avoid an unconditional `git pull` which can
# result in unwanted merge commits all over $HOME.  This redefinition
# is based on the value of git_update set in the dgit plugin.  Note
# that the dgit lib has to have unconditional `git pull` to match
# global myrepos conventions
git_update = 
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
    current_branch_remote="$(git config branch.$current_branch.remote || true)"
    if [ "$(echo $current_branch | cut -s -d/ -f1)" = "dgit" ]; then
        echo "I: current branch is dgit/foo; doing \`dgit pull\`"
        dgit pull
    else
        echo "I: current branch is ordinary; doing \`git pull --ff-only\`"
        git pull --ff-only
    fi
    for remote in $(git remote); do
        # skip if we just called `git pull` on this remote
        if ! ([ "$remote" = "$current_branch_remote" ] || [ "$remote" = "dgit" ]); then
            echo "I: fetching $remote"
            git remote update "$remote"
        fi
    done
    for suite in $(git show-ref | grep refs/remotes/dgit/dgit | cut -d/ -f5 ); do
        # skip if we just called `dgit pull` on this suite
        if ! [ "$current_branch" = "dgit/$suite" ]; then
            echo "I: fetching dgit suite $suite"
            dgit fetch $suite
        fi
    done

# --- Adam Spiers' plugin for managing dotfile symlinks with mr

include =
    # stow is not available on Windows
    if [ -e "$HOME/src/dotfiles/lib/mr/stow" \
         -a ! "$(perl -e 'print $^O')" = "msys" ]; then
        cat "$HOME/src/dotfiles/lib/mr/stow"
    fi

# --- joeyh's code for specifying what machine we're on for repo skip
# --- tests, plus my code for detecting Git-on-Windows

lib =
    win32() {
        test "$(perl -e 'print $^O')" = "msys"
    }
    #
    if win32; then
       hostname=$(hostname)
    else
       hostname=$(hostname -s)
    fi
    #
    whoami="$(whoami)"
    # cut off the machine name on Windows
    win32 && whoami=${whoami##*\\}
    #
    on() {
        for host in $@; do
            if [ "${host%@*}" != "${host#*@}" ]; then
                if [ "$whoami" != "${host%@*}" ]; then
                    continue
                fi
                host="${host#*@}"
            fi
            if [ "$hostname" = "$host" ]; then
                return 0
            fi
        done
        return 1
    }
    workstation() {
        on swhitton@artemis swhitton@zephyr spwhitton@hephaestus spwhitton@iris
    }
    mine() {
        workstation || on swhitton@athena
    }
    # tucson() {
    #     on artemis shortgeese athena hephaestus iris
    # }
    gcrypt() {
        which git-remote-gcrypt >/dev/null 2>/dev/null
    }

# --- run a command on athena in a sane environment

lib =
    athena_cmd () {
        # here we rely on the fact that ssh already passes argument
        # through `/bin/sh -c' (note use of single-quotes in this
        # function)
        ssh athena 'cd $HOME/'"$1"' && . $HOME/.shenv && '"$2"
    }

# --- standard procedures

lib =
    homedir_mkdirs() {
        (
            cd $HOME
            mkdir -p \
                .ssh \
                tmp \
                src \
                lib \
                lib/athena \
                local/mutt \
                local/mpd \
                local/anacron/spool \
                local/src \
                local/bin \
                local/big \
                local/lib \
                local/pub \
                local/auth
            # known_hosts needs to exist or zsh complains
            touch local/big/.duplicity-ignore src/.mrconfig .ssh/known_hosts
            chmod 700 local/auth
            # [ -L "src/build-area" ] || ln -s -T /tmp/debuild src/build-area
        )
    }
# --- primary dotfiles repository

[$HOME/src/dotfiles]
checkout = git clone https://git.spwhitton.name/dotfiles.git dotfiles
stowable = true

update =
    # always make a go of updating master
    branch="$(git rev-parse --abbrev-ref HEAD)"
    git checkout master
    git pull --ff-only
    git checkout $branch
push =
    # always make a go of pushing master
    git push origin master
rebase =
    # usual rebasing pattern.  Per dotfiles repo policy (excluding
    # win32 case), the branch being rebased will always be rebaseable
    # on master, since it is only checked out and committed to on this
    # host
    branch="$(git rev-parse --abbrev-ref HEAD)"
    hostname="$(hostname -s)"
    if [ "$branch" = "win32" -o "$branch" = "$(hostname -s)" ]; then
        git rebase master
    # fallback case: if we're on another branch but a host branch exists
    elif git branch | grep -q "^  $hostname$"; then
        git checkout $hostname
        git rebase master
    fi

fixups =
    # Use a rebasing workflow since I'm the only person who ever
    # commits to this repo
    git config branch.master.rebase true
    git config branch.autosetuprebase always
    #
    if win32; then
        ( cd ~/src/dotfiles/bin && cmd "/C win32setup.bat" )
    else
        # Manually symlink ~/.mrconfig so that we can always use mr
        # even if dotfiles are unstowed.  Called 'home-mrconfig' to
        # avoid any chainloading
        ln -sf $HOME/src/dotfiles/home-mrconfig $HOME/.mrconfig
        #
        # Ensure that ~/src/dotfiles/home-mrconfig not stowed
        ln -sf $HOME/src/dotfiles/.stow-global-ignore $HOME
        #
        homedir_mkdirs
        chmod -Rf 600 $HOME/.msmtprc $HOME/local/auth/* || true
        #
        $HOME/src/dotfiles/bin/loadcron || true
        $HOME/src/dotfiles/bin/loadsshkeys || true
        $HOME/src/dotfiles/bin/mkcabalc
    fi

# clean-ups so that initial stow will be successful
pre_stow =
    homedir_mkdirs
    $HOME/src/dotfiles/bin/unskel

# set up Emacs conf & libs
post_stow = $HOME/src/dotfiles/bin/bytecompile-emacsd
post_restow = $HOME/src/dotfiles/bin/bytecompile-emacsd

# --- private dotfiles repositories

[$HOME/src/priv]
checkout = git clone gcrypt::rsync://athena:/srv/gcrypt/priv.git priv
stowable = true

# this repository can't be checked out until we install
# git-remote-gcrypt.  And thanks to gcrypt being slow, skip if I run
# via fmr.
skip = (! gcrypt) || (! workstation)

fixups =
        chmod 600 .passwddb.pet .s3ql/authinfo2 .gnupg/*.kbx .gnupg/private-keys-v1.d/*.key
        git config remote.origin.gcrypt-publish-participants true
        git config remote.origin.gcrypt-participants 0x0F56D0553B6D411B
        git config gcrypt.publish-participants true
        git config gcrypt.participants 0x0F56D0553B6D411B
autoci =
        git add .passwddb.pet .labbook.gpg
        git commit -a -m "auto passwddb and labbook commit on $(hostname -s)" || true
pre_update = mr autoci

# since dotfiles repo also stows into ~/.gnupg, and athpriv repo stows
# into ~/.duply, make the dirs first
pre_stow = homedir_mkdirs
post_stow = load-trustdb

[$HOME/src/athpriv]
checkout = git clone athenap:athpriv athpriv
stowable = true
skip = ! mine

# since priv repo also stows into ~/.gnupg, make the dir first
pre_stow = homedir_mkdirs

# --- hosts configuration

[$HOME/src/propellor]
# this has to be a full URL, as during a spin of a host, propellor
# sets this as the remote in /usr/local/propellor and it must be
# possible to pull from it without root having my .gitconfig checked
# out
checkout = git clone https://git.spwhitton.name/propellor propellor --branch spw3conf
post_checkout =
    cd propellor
    git remote add -f upstream github:joeyh/propellor.git
    which cabal && cabal sandbox init || true
    # from <https://propellor.branchable.com/coding_style/> we use a
    # hook here because dgit's requirements mean on the debian branch
    # we have to clean .cabal-sandbox etc. before a build (so we
    # always have to use sbuild)
    cp ~/lib/hooks/propellor-post-checkout ~/src/propellor/.git/hooks/post-checkout
    chmod 755 .git/hooks/post-checkout
    echo ".dir-locals.el" >> .git/info/exclude
fixups =
    # check that the link isn't already in place before making the link
    # because otherwise we get an infinite loop of links that breaks propellor
    [ -L ~/.propellor ] || ln -sf ~/src/propellor ~/.propellor
    # disabled until spw3conf is merged into spwconf
    # git config propellor.spin-branch spw3conf
    git config propellor.forbid-dirty-spin true

# this could be more fine-grained
skip = ! mine

# --- personal website source

[$HOME/src/wiki]
checkout = git clone https://git.spwhitton.name/wiki
skip = ! mine

# --- primary git annex

# TODO: consider using /usr/share/mr/git-annex helper to simplify this
# configuration (override its update definition to avoid --content)
# (and isclean defn can be generalised)

[$HOME/lib/annex]
checkout = git clone gcrypt::rsync://athena:/srv/gcrypt/annex.git annex
post_checkout =
    cd annex
    git annex init
    git annex enableremote athena rsyncurl=athena:/srv/rsync/annex
skip = (! workstation)

update = git annex sync --no-content origin
push =
    git annex sync --no-content origin
    git annex sync --content athena
    git annex sync --no-content origin
fixups =
    git config push.default matching
    git config remote.origin.gcrypt-publish-participants true
    git config remote.origin.gcrypt-participants 0x0F56D0553B6D411B
    git config gcrypt.publish-participants true
    git config gcrypt.participants 0x0F56D0553B6D411B
    git config annex.startupscan false
    git config annex.autocommit true # needed for ga sync
    git config remote.origin.annex-ignore true
sync = git annex sync --no-content origin

# --- personal website big files annex

[$HOME/lib/wikiannex]
checkout = git clone athena:wikiannex.git
status = git annex status       # direct mode on athena, so status won't work
post_checkout =
    cd wikiannex
    git annex init
    git config remote.origin.annex-ignore false
    # ^ the git-annex-init sets this wrong
    if [ "$(hostname -s)" = "athena" ]; then
        git annex direct
    fi
    if workstation; then
        git remote add bkupsd /media/${USER}/bkupsd/git/athena/wikiannex.git
        git remote add m3 /media/${USER}/m3/git/athena/wikiannex.git
    fi
update = git annex sync --no-content         # no pull in direct mode
push = git annex sync --content
skip = ! mine

# --- git annex for university stuff

[$HOME/lib/dionysus]
checkout = git clone athenap:dionysus
post_checkout =
    cd dionysus
    git annex init
    git annex direct
status = git annex status
update = git annex sync --no-content
push = git annex sync --content
sync = sync-for-dionysus
isclean = test -z "$(git annex status)" || (git annex status && exit 1)

# origin remote is just for keeping a backup copy of metadata.  athena
# remote, in $HOME on athena, contains a copy of content.  At present,
# origin remote only updated by weekly coldbkup script
fixups =
    git config push.default matching
    git config annex.startupscan false
    git config annex.autocommit true # needed for ga sync
    git config remote.origin.annex-ignore true

skip = ! workstation

# --- git annex for podcasts

[$HOME/lib/podcasts]
checkout = git clone athenap:podcasts
post_checkout =
    cd podcasts
    git annex init
status = git annex status
update = git annex --no-content sync
push = git annex --no-content sync
isclean = test -z "$(git annex status)" || (git annex status && exit 1)

# origin remote is just for keeping a backup copy of metadata.  athena
# remote, in $HOME on athena, contains a copy of content.  At present,
# origin remote only updated by weekly coldbkup script
fixups =
    git config push.default matching
    git config annex.startupscan false
    git config annex.autocommit true # needed for ga sync
    git config remote.origin.annex-ignore true

skip = ! workstation

# --- git annex for use with rtorrent

[$HOME/lib/rt]
checkout = git clone gcrypt::rsync://athena:/srv/gcrypt/rt.git rt
post_checkout = cd rt && git annex init
status = git annex status --fast
update = git annex sync --no-content origin
push = git annex sync --no-content origin
autoci = (git annex add . && git commit -m "auto commit on $(hostname -s)") || true
fixups =
    git config push.default matching
    git config gcrypt.publish-participants true
    git config remote.origin.gcrypt-publish-participants true
    git config remote.origin.gcrypt-participants 0x0F56D0553B6D411B
    git config annex.startupscan false
    git config annex.autocommit true # needed for ga sync
    git config remote.origin.annex-ignore true
    if [ -d "$(hostname -s)" ]; then
        mkdir -p $HOME/local/rt
        cd $HOME/local/rt
        touch .duplicity-ignore
        mkdir -p session incomplete
        if ! [ -e "complete" ]; then
            ln -s $HOME/lib/rt/complete complete
        fi
        if ! [ -e "watch" ]; then
            ln -s $HOME/lib/rt/$(hostname -s) watch
        fi
    fi

skip = (! workstation)

# --- source code repositories registered to their own mr config file

[$HOME/src]
chain = true

# Always skip, since this is a dummy repository entry in order to
# chainload.
skip = ! [ "$MR_ACTION" = "stowable" ]

# --- my personal documents.  Override my global update command back
# --- to the myrepos default so that git automatically pulls and
# --- merges.  Skipped on non-local hosts

[$HOME/doc]
checkout = git clone athenap:doc doc
update = git pull "$@"
skip = ! (mine || on spwhitton@shortgeese)

# set file modification times to last commit for deft.el
fixups = git-utime

# before pulling, automatically commit in the same way that my cron job does
pre_update = (! win32) && doccheckin
# ... and let me do it manually
autoci = doccheckin || true

# quick syncs
sync = mr update && mr push

# --- static websites on web host boxes

[$HOME/public_html]
clone = git clone https://git.spwhitton.name/sageweb public_html
skip = ! on spwhitton@sage

[$HOME/html]
clone = git clone https://git.spwhitton.name/sdfweb html
skip = ! on faeroes             # TODO just check if host is *.sdf.org

# --- my offline e-mail (& machine's postfix queue)

[$HOME/.fmail]
sync = movemail
update = mbsync --quiet fastmail
push = movemail

# Don't do anything if I don't use mbsync on this machine, or I
# didn't run one of the sync or update commands.
skip = ! [ -d "$HOME/.fmail" ] || ! ( [ "$MR_ACTION" = "stowable" ] || [ "$MR_ACTION" = "push" ] || [ "$MR_ACTION" = "sync" ] || [ "$MR_ACTION" = "update" ] )

# this is slower than other repos for which sync is defined
order = 12

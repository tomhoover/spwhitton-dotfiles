# -*- mode: conf -*-

# --- global settings

[DEFAULT]
git_gc = git gc "$@"

# Just a single job for now because otherwise sometimes hangs due to
# SSH connection sharing.
jobs = 1

# actions to be configured per repository
git_sync = :
git_rebase = :

# In general, I don't want merge commits to be made en masse by mr
git_update = git pull --ff-only "$@"

# --- Adam Spiers' plugin for managing dotfile symlinks with mr

include =
    if [ -e ~/lib/mr/stow ]; then
        cat ~/lib/mr/stow
    # If the stow mr library gets included on Windows then we'll get errors on
    # e.g. mr update because mr'll try to call stow but it's not installed.
    # This second if clause will find the library on Windows, so check for
    # that.  We can't do this with my win32 command because inside include= is
    # a subshell that can't access stuff defined in mr config lib= directives.
    elif [ -e ~/src/dotfiles/lib/mr/stow -a ! "$(perl -e 'print $^O')" = "msys" ]; then
        cat ~/src/dotfiles/lib/mr/stow
    elif [ -e ~/local/lib/stow ]; then
        cat ~/local/lib/stow
    fi
lib =
    # reimplement kitenet-mr stow library function which relies on mr
    # "-r" parameter which is only present in aspiers' outdated fork
    is_stowable () {
            [ -z "$MR_DISABLE_STOW" ] &&
            ( mr stowable >/dev/null 2>&1 )
    }

# --- joeyh's code for specifying what machine we're on for repo skip
# --- tests, plus my code for detecting Git-on-Windows

lib =
    fast() {
        if [ "${MR_FAST}" = "true" ]; then
            return 0
        else
            return 1
        fi
    }
    win32() {
        if [ "$(perl -e 'print $^O')" = "msys" ]; then
            return 0
        else
            return 1
        fi
    }
    if win32; then
       hostname=$(hostname)
    else
       hostname=$(hostname -s)
    fi
    whoami="$(whoami)"
    # cut off the machine name from whoami on Windows
    if win32; then
        whoami=${whoami##*\\}
    fi
    on() {
        for host in $@; do
            if [ "${host%@*}" != "${host#*@}" ]; then
                if [ "$whoami" != "${host%@*}" ]; then
                    continue
                fi
                host="${host#*@}"
            fi
            if [ "$hostname" = "$host" ]; then
                return 0
            fi
        done
        return 1
    }
    mine() {
        on swhitton@artemis || on swhitton@zephyr || on swhitton@SPWHITTON || on swhitton@athena
    }
    workstation() {
        on swhitton@artemis || on swhitton@zephyr
    }
    gcrypt() {
        which git-remote-gcrypt >/dev/null 2>/dev/null
    }

# --- A function for enabling Emacs mode for calling `git wip' on file
# --- save.  Warning: removes any other magit extensions enabled.  So
# --- be sure to add those to this function somehow if I ever start
# --- using any.
lib =
    wip() {
        git config --remove-section magit
        git config --add magit.extension wip-save
    }

# --- primary dotfiles repository

[src/dotfiles]
lib =
        # manually set a variable that aspiers' outdated fork of mr
        # sets, that his kitenet-mr stow library needs
        MR_NAME=dotfiles

stowable = true
checkout = git clone https://git.spwhitton.name/dotfiles.git dotfiles
update =
    # always make a go of updating master
    branch="$(git rev-parse --abbrev-ref HEAD)"
    git checkout master
    git pull --ff-only
    git checkout $branch
push =
    # always make a go of pushing master
    git push origin master
rebase =
    # common rebasing patterns
    branch="$(git rev-parse --abbrev-ref HEAD)"
    if [ "$branch" = "win32" ]; then
        git checkout win32
        git rebase master
    # fallback elif to still do something automatic in the simplest case
    elif [ "$branch" = "$hostname" ]; then
        # Determine nearest parent branch by
        # <https://stackoverflow.com/questions/3161204/find-the-parent-branch-of-a-branch#comment35666518_17843908>.
        # This should always be master per README, but check just in
        # case.
        parent="$(git show-branch -a | grep '*' | egrep -v "\[${branch}[0-9^~]*\]" | head -n1 | sed 's/.*\[\(.*\)\].*/\1/' | sed 's/[\^~].*//')"
        if [ "$parent" = "master" ]; then
            git checkout $branch
            git rebase master
        fi
    fi
# sync = git push origin master

# skip this repository if stow is not installed, and we're not on
# Windows where we don't use stow.  This should be a prompt to
# download a tarball, and do
#       ./configure --prefix=$HOME/local && make install
skip = ! which stow >/dev/null && ! win32

# stow won't overwrite a real ~/.mrconfig with a symlink to the
# version in my dotfiles repository.  Cannot just delete .mrconfig
# before a stow, because then mr can't tell stow what to do.  So just
# do it with manual fixup and have stow ignore this file.  Name is
# different to avoid mr trying to chain load it at any point

# similarly for .stow-global-ignore
fixups =
    if ! win32; then
        ln -sf $HOME/src/dotfiles/home-mrconfig $HOME/.mrconfig
        ln -sf $HOME/src/dotfiles/.stow-global-ignore $HOME
        mkdir -p $HOME/local/mutt $HOME/.ssh $HOME/local/mpd $HOME/local/anacron/spool
        mkdir -p $HOME/tmp $HOME/src $HOME/local/src $HOME/local/bin $HOME/local/big $HOME/local/lib $HOME/local/pub
        # set up auth info folder: the "|| true" is because if the
        # folder is empty the final recursive chmod will fail
        mkdir -p $HOME/local/auth && chmod 700 $HOME/local/auth && chmod -R 600 $HOME/local/auth/* 2>/dev/null || true
        touch $HOME/local/big/.duplicity-ignore
        touch $HOME/.ssh/known_hosts
        chmod 600 $HOME/.msmtprc
    fi
    # we don't want git doing any automated merges of master, or other
    # intermediate branches.  mr is configured not to do this (see
    # redefinition of git_update at top of this file) but I often run
    # git pull in this repo myself
    git config branch.master.rebase true
    git config branch.autosetuprebase always
    # update crontab
    if ! win32; then
        # use absolute path because maybe we only just stowed so this
        # shell doesn't have $PATH setup by .shenv
        $HOME/bin/loadcron || true
        $HOME/bin/loadsshkeys || true
        $HOME/bin/mkcabalc
    fi
    if win32; then
        cd ~/src/dotfiles/bin
	cmd "/C win32setup.bat"
    fi
    # generate haskell-mode autoloads
    cd $HOME/src/dotfiles/.emacs.d/pkg/haskell-mode
    make

# Empty out /etc/skel junk (must use full path to this script because
# it's pre stow!), and create ~/.emacs.d/ before stowing so that the
# files inside are symlinks, rather than the whole dir being a
# symlink.  That way Emacs junk that gets dumped in ~/.emacs.d doesn't
# have to be put into .gitignore.  Similarly the XDG autostart folder,
# .ssh and lib and more
pre_stow = $HOME/src/dotfiles/bin/unskel; mkdir -p ~/.emacs.d ~/.config/autostart ~/.ssh ~/lib ~/.cabal ~/.config/xfce4/desktop ~/.config/xfce4/xfconf/xfce-perchannel-xml ~/.gnupg ~/.config/Thunar ~/.irssi
pre_checkout = mkdir -p ~/.emacs.d  ~/.config/autostart ~/.ssh ~/lib ~/.cabal ~/.xmonad ~/.config/xfce4/desktop ~/.config/xfce4/xfconf/xfce-perchannel-xml ~/.gnupg ~/.config/Thunar ~/.irssi

# GTK insists on replacing the symlink to its bookmarks file with the
# actual file even if the bookmarks in that file don't change (XFCE
# only replaces symlinks to its config files if its changed them).
# Fix this situation in the simplest case to avoid mr restow giving an
# error.  Don't try anything fancy if the files are different; let the
# restow command give an error and the user fix it.
lib =
    fix_gtk_bookmarks () {
        if ! win32; then
            if ! [ -L ~/.gtk-bookmarks ]; then
                # file in home directory is not a link
                if diff -q ~/src/dotfiles/.gtk-bookmarks ~/.gtk-bookmarks > /dev/null; then
                    rm ~/.gtk-bookmarks
                fi
            fi
        fi
    }
pre_unstow = fix_gtk_bookmarks
pre_restow = fix_gtk_bookmarks
pre_update = fix_gtk_bookmarks

# --- private dotfiles repositories

[src/priv]
lib =
        # manually set a variable that aspiers' outdated fork of mr
        # sets, that his kitenet-mr stow library needs
        MR_NAME=priv
stowable = true
checkout = git clone gcrypt::athenap:priv priv

# this repository can't be checked out until we install
# git-remote-gcrypt.  And thanks to gcrypt being slow, skip if I run
# via fmr.
skip = (! gcrypt) || lazy || fast

# convenience automatic permission setting and checking in of
# frequently changed files
fixups =
        chmod 600 .passwddb.pet .s3ql/authinfo2 .gnupg/*.gpg
        git config remote.origin.gcrypt-publish-participants true
        git config remote.origin.gcrypt-participants 0x3B6D411B
        git config gcrypt.publish-participants true
        git config gcrypt.participants 0x3B6D411B
pre_update =
        git add .passwddb.pet .labbook.gpg
        git commit -a -m "auto passwddb and labbook commit on $(hostname -s)" || true
autoci =
        git add .passwddb.pet .labbook.gpg
        git commit -a -m "auto passwddb and labbook commit on $(hostname -s)" || true

# since dotfiles repo also stows into ~/.gnupg, and athpriv repo stows
# into ~/.duply, make the dirs first
pre_stow = mkdir -p ~/.gnupg ~/.duply

[src/athpriv]
lib =
        # manually set a variable that aspiers' outdated fork of mr
        # sets, that his kitenet-mr stow library needs
        MR_NAME=athpriv
stowable = true
checkout = git clone athenap:athpriv athpriv
skip = ! mine

# since priv repo also stows into ~/.gnupg, make the dir first
pre_stow = mkdir -p ~/.duply ~/.irssi

# --- hosts configuration

[src/propellor]
# This URL needs to be one that will work without my ~/.gitconfig
# insteadOf rewriting rules in place
checkout = git clone https://git.spwhitton.name/propellor propellor --branch spwconf

# Get a sandbox going.  Dependencies should already be in place with
# system-wide propellor package.
post_checkout =
    cd propellor
    git remote add -f upstream github:joeyh/propellor.git
    cabal sandbox init
post_update = git fetch upstream
# check that the link isn't already in place before making the link
# because otherwise we get an infinite loop of links that breaks propellor
fixups = if ! [ -L ~/.propellor ]; then ln -sf ~/src/propellor ~/.propellor; fi

# Skip if we're not on my personal machine, or I haven't got GHC and
# friends up and running yet (see comproc.org for how to do that).
skip = (! (on swhitton@artemis || on swhitton@zephyr)) || (! which cabal >/dev/null)

# --- personal website source

[src/wiki]
checkout = git clone https://git.spwhitton.name/wiki
skip = ! mine

# --- primary git annex

[lib/annex]
checkout = git clone athenap:annex

# basic commands
update = git annex sync origin ma
push = git annex sync --content origin ma
fixups =
    git config push.default matching
    git config remote.ma.gcrypt-publish-participants true
    git config remote.ma.gcrypt-participants 0x3B6D411B
    git config remote.origin.gcrypt-publish-participants true
    git config remote.origin.gcrypt-participants 0x3B6D411B
    git config gcrypt.publish-participants true
    git config gcrypt.participants 0x3B6D411B
    git config annex.startupscan false
    git config annex.autocommit false
    # set upstream so that mr can tell when I need to push
    git branch -u origin/master master
    git branch -u origin/git-annex git-annex

sync = git annex sync origin ma

# manual checkouts only, and skip when we're in a hurry and used 'fmr'
# instead of 'mr'
skip = lazy || fast

# --- personal website big files annex

[lib/wikiannex]
checkout = git clone git@spwhitton.name:wikiannex.git
status = git annex status       # direct mode on athena, so status won't work
post_checkout =
    if [ "$(hostname -s)" = "athena" ]; then
        git annex direct
    fi
    if workstation; then
        git remote add bkupsd /media/${USER}/bkupsd/git/athena/wikiannex.git
        git remote add m3 /media/${USER}/m3/git/athena/wikiannex.git
    fi
skip = ! mine

# --- git annex for use with rtorrent

[lib/rt]
checkout = git clone gcrypt::athenap:rt
status = git annex status --fast
update = git annex sync origin
push = git annex sync origin
autoci = (git annex add . && git commit -m "auto commit on $(hostname -s)") || true
fixups =
    git config push.default matching
    git config gcrypt.publish-participants true
    git config remote.origin.gcrypt-publish-participants true
    git config remote.origin.gcrypt-participants 0x3B6D411B
    git config annex.startupscan false
    git config annex.autocommit false
    git config remote.origin.annex-ignore true
    if [ -d "$(hostname -s)" ]; then
        mkdir -p $HOME/local/rt
        cd $HOME/local/rt
        touch .duplicity-ignore
        mkdir -p session incomplete
        if ! [ -e "complete" ]; then
            ln -s $HOME/lib/rt/complete complete
        fi
        if ! [ -e "watch" ]; then
            ln -s $HOME/lib/rt/$(hostname -s) watch
        fi
    fi

# manual checkouts only, and skip when we're in a hurry and used 'fmr'
# instead of 'mr'
skip = lazy || fast

# --- source code repositories registered to their own mr config file

[src]

# Chain load unless we invoked mr via fmr alias.
chain = ! [ "${MR_FAST}" = "true" ]

# Always skip, since this is a dummy repository entry in order to
# chainload.
skip = ! [ "$MR_ACTION" = "stowable" ]

[src/srem]
checkout = git clone https://git.spwhitton.name/srem.git srem
post_checkout = ln -s $HOME/src/srem/dist/build/srem/srem $HOME/local/bin/srem
skip = lazy

# --- my personal documents, website and blog.  Override my global
# --- update command back to the myrepos default so that git
# --- automatically pulls and merges.  Skipped on non-local hosts

[doc]
checkout = git clone 'ssh://ma/~/local/git/doc.git' 'doc'
update = git pull "$@"
skip = ! ( mine || on spw@ma )

# set file modification times to last commit
fixups = git-utime

# automatically commit in the same way that my cron job does before pulling
pre_update = if ! win32; then doccheckin; fi
# ... and let me do it manually
autoci = doccheckin || true

# quick syncs
sync =
    if win32; then
        cmd "/C doccheckin.bat" && git pull && git push
    else
        doccheckin && git pull && git push
    fi

# --- static websites

[public_html]
clone = git clone https://git.spwhitton.name/sageweb public_html
skip = ! on spwhitton@sage

[html]
clone = git clone https://git.spwhitton.name/sdfweb html
skip = ! on faeroes

# --- my offline e-mail (& machine's postfix queue)

[.fmail]
sync = movemail
update = mbsync --quiet fastmail
push = movemail

# Don't do anything if I don't use mbsync on this machine, or I
# didn't run one of the sync or update commands.
skip = ! [ -d "$HOME/.fmail" ] || ! ( [ "$MR_ACTION" = "stowable" ] || [ "$MR_ACTION" = "push" ] || [ "$MR_ACTION" = "sync" ] || [ "$MR_ACTION" = "update" ] )
